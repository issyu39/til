## モバイルアプリのユーザー エクスペリエンス (Mobile app user experiences)
標準的なAndroidアプリは、さまざまなアプリコンポーネント（Activity、Fragmentなど）で構成されているが、デバイスにはリソースに限りがあるため、OSは新たなアプリのリソースを確保するために、アプリプロセスを任意のタイミングで強制終了する場合がある。  
このような条件を考慮すると、アプリコンポーネントは個別に順不同で起動され、OSやユーザーによって随時破棄される可能性がある。デベロッパーはこうしたイベントを制御できないため、アプリのデータや状態をコンポーネント内に保存したり、メモリ内に保持したりしないようにする。また、コンポーネントは互いに依存してはいけない。   

## アーキテクチャに関する一般的な原則 (Common architectural principles)

### 関心の分離 (Separation of concerns)
すべてのコードを1つのActivityまたはFragmentに記述するのはよくある間違いである。  
これらのUIベースのクラスには、UIやOSとのやり取りを処理するロジックのみを含める。  
これらのクラスをできる限りシンプルに保つことで、ライフサイクルに関連する多くの問題を回避することができ、テストのしやすさも向上する。  


### UIをモデルで操作する (Drive UI from data models)
もう1つの重要な原則は、UIをモデルで操作することであり、永続モデルをおすすめする。  
モデルとは、アプリのデータを処理するコンポーネントである。  
モデルはアプリのViewオブジェクトやアプリコンポーネントから独立しているため、アプリのライフサイクルや関連する問題の影響を受けない。  
データの管理責任が明確に定義されたモデルクラスを基盤としてアプリを作成することで、アプリのテストのしやすさと一貫性を向上させることができる。

永続モデルが望ましい理由として、次の点が挙げられる。

- Android OS がアプリを破棄してリソースを解放してもデータが失われない。
- ネットワーク接続が不安定または利用不可の場合でもアプリが動作し続ける。

### 信頼できる唯一の情報源 (Single source of truth)
アプリ内で新しいデータ型を定義するときは、信頼できる唯一の情報源（SSOT）を割り当てる必要がある。SSOTはそのデータの「オーナー」であり、SSOTのみがそのデータを変更またはミューテーションできる。  
そのために、SSOTは不変の型を使用してデータを公開する。SSOTがデータを変更するには、関数を公開するか、他の型が呼び出すことができるイベントを受け取る。     
  
このパターンには、次のようないくつかのメリットがある。  
  
- 特定のデータ型に対するすべての変更を1か所に集約できる。  
- 他の型によって改ざんされないようにデータを保護できる。
- データに対する変更が追跡しやすくなり、それによりバグを見つけやすくなる。
  
オフラインファーストのアプリでは、アプリデータの信頼できる情報源は、通常はデータベースである。場合によっては、ViewModelやUIが信頼できる情報源となる。  

### 単方向データフロー (Unidirectional Data Flow)
単方向データフロー（UDF）パターンに関するAndroidのガイドでは、信頼できる唯一の情報源の原則がよく使用される。
UDFでは、状態は一方向にのみ流れる。データを変更するイベントはその反対方向に流れる。  
Androidでは、一般的に状態またはデータは、上位スコープの階層の型から下位スコープの階層の型に流れる。一般的にイベントは、下位スコープの型からトリガーされ、対応するデータ型のSSOTに到達するまで流れる。
たとえば、一般的にアプリデータはデータソースからUIに流れる。ボタンの押下などのユーザー イベントはUIからSSOTに流れ、SSOTでアプリデータが変更されて、不変の型で公開される。    
このパターンにより、データの整合性の保証が向上し、間違いの発生が減り、デバッグが簡単になります。つまり、SSOT パターンのすべてのメリットが実現される。

**アプリ アーキテクチャ ガイド**  
https://developer.android.com/jetpack/guide?s=09

## Androidアプリの推奨アーキテクチャ (Recommended app architecture)
共通のアーキテクチャの原則を考慮すると、各アプリケーションは少なくとも2つのレイヤーを持つ必要がある。   
矢印はクラス間の依存を表しており、例えばドメイン層はデータ層に依存する。

- アプリケーションのデータをスクリーンに表示するUI層
- ビジネスロジックを含み、アプリケーションデータを公開するデータ層
- UI層とデータ層間のインタラクションを簡略化し再利用するためのドメイン層(必要であれば)
<img width="600" alt="スクリーンショット 2020-11-24 16 38 44" src="https://user-images.githubusercontent.com/16067422/146178460-c53bf534-7c27-4256-9ccf-c2a49e75bbfb.png">

### UI層 (UI layer)
UI層の役割としてはアプリケーションのデータをスクリーンに表示することである。ユーザー操作（ボタンの押下など）または外部入力（ネットワークレスポンスなど）によってデータが変更されるたびに、変更を反映するようにUIを更新する必要がある。  
UI層は以下の2つから成り立っている。
- データをスクリーンに描画する`UI elements` ViewやJetpack Composeを使用する
- View Modelのような`State holders` データを保持したり、UI層にそれを公開したりロジックを処理する
<img width="600" alt="スクリーンショット 2020-11-24 16 38 44" src="https://user-images.githubusercontent.com/16067422/146179702-88574702-3167-4031-8f58-63100e4f0ca5.png">

詳細は以下  
https://developer.android.com/jetpack/guide/ui-layer

### データ層 (Data layer)
データ層はビジネスロジックを含む層である。ビジネスロジックはアプリに価値をもたらすものであり、アプリがデータを作成、保存、変更する方法を決定するルールで構成されている。 
データ層はそれぞれ複数のデータソースを含むリポジトリ群から成り、Repositoryはデータの種類に応じてそれぞれ作る必要がある。   
たとえば、映画に関するデータであれば`MoviesRepository`クラス、支払いに関するデータであれば`PaymentsRepository`クラスを作成する。
  
<img width="600" alt="スクリーンショット 2020-11-24 16 38 44" src="https://user-images.githubusercontent.com/16067422/146195396-8f347210-62a9-49b3-8e22-9c037d773b00.png">

Repositoryの役割として以下がある。  
- アプリ内に他の部分にデータを公開する
- データに対する変更の一元化
- 複数のデータソース間のコンフリクトを回避する
- データソースをアプリ内の他の部分から抽象化する
- ビジネスロジックを含む

各データソースクラスは、ファイル、ネットワーク・ソース、ローカル・データベースなど、1つのデータソースのみを扱う責任を持つ必要がある。

詳細は以下   
https://developer.android.com/jetpack/guide/data-layer

### ドメイン層 (Domain layer)
ドメイン層はUI層とデータ層の間に位置する、任意のレイヤーである。  
ドメイン層は複雑なビジネスロジックや複数のViewModelで再利用される単純なビジネスロジックをカプセル化する役割がある。  
全てのアプリにこれらの要件があるわけではないので、この層はオプションである。    

<img width="600" alt="スクリーンショット 2020-11-24 16 38 44" src="https://user-images.githubusercontent.com/16067422/146197610-a20cbcc8-f73d-4670-8d33-5ad0604d6ab8.png">

この層のクラスは一般的に`use cases`または`interactors`と呼ばれている。

詳細は以下   
https://developer.android.com/jetpack/guide/domain-layer

## コンポーネント間の依存関係を管理する
アプリ内のクラスは適切に機能するために他のクラスに依存している。  
特定のクラスの依存をまとめるために、以下のパターンを利用できる。
- *Dependency injection (DI)* : 依存関係の注入を利用すると、クラスの依存関係を構築することなく定義できる。ランタイムには、別のクラスがこの依存関係を提供する。  
- *Service locator* : サービスロケータパターンでは、クラスが依存関係を作成せずに取得できるレジストリが提供される。

こうしたパターンでは、コードが重複して煩雑になることなく依存関係を明確に管理できるため、コードの拡張が可能になる。  
さらに、テスト版と製品版の実装を簡単に切り替えることができる。  
依存関係の注入のパターンに沿って、Android アプリでHiltライブラリを使用することがおすすめ。  
Hiltでは、依存関係ツリーをたどって自動的にオブジェクトが構築され、コンパイル時の依存関係が保証され、Androidフレームワーククラスの依存関係コンテナが作成される。  

## 一般的なベストプラクティス
問題解決の方法はたくさん考えられる。  
複数のアクティビティやフラグメント間でデータをやり取りする、リモートデータを取得してオフラインモード用にローカルで永続化するなど、重要なアプリで対処する一般的なシナリオにはさまざまなものがある。  
以下の推奨事項は必須ではないが、以下の事項に従うことによって多くの場合でコードベースの堅牢性を高め、テストとメンテナンスを長期にわたって実施できるようになる  

- **アプリのコンポーネントにデータを格納しない**  
アプリのエントリポイント（アクティビティ、サービス、ブロードキャストレシーバなど）をデータソースとして指定しないようにする。その代わり、そのエントリポイントに関連するデータのサブセットを取得する他のコンポーネントとの調整だけを行うべきである。  
- **Androidクラスへの依存を減らす**  
アプリのコンポーネントは、ContextやToastなど、AndroidフレームワークSDKに依存する唯一のクラスにする必要がある。そこからアプリの他のクラスを抽象化すると、テストがしやすくなり、アプリ内の結合を軽減できる。
- **アプリの各種モジュール間の役割の境界を明確に定義する**    
たとえば、ネットワークからデータを読み込むコードを、コードベース内の複数のクラスやパッケージに散在させないようにする。  
同様に、関連のない複数の処理（データキャッシングとデータバインディングなど）を同じクラスで定義しないようにする。  
- **各モジュールからの公開はできるだけ行わない**    
たとえば、モジュールの内部実装の詳細を公開するショートカットを作成しようとしないようにする。
短期的には時間を少し節約できるかもしれないが、コードベースが発展するにつれて何倍もの技術的負債を負うことになる可能性がある。 
- **アプリ固有の部分に集中し、他のアプリとの差別化を図る**    
ボイラープレートのコードを書いて車輪の再発明をしするのではなく、アプリをユニークにする部分に時間とエネルギーを集中させる。  
繰り返しのボイラープレートコードの記述にはJetpackライブラリやその他の推奨ライブラリを利用する。
- **アプリの各部分を個別にテストできるようにする方法を検討する**    
たとえば、ネットワークからデータを取得するための明確に定義されたAPIを用意することで、そのデータをローカルデータベースに永続化するモジュールを簡単にテストできるようになる。     
そうせずに、2つのモジュールのロジックを1か所に混在させたり、ネットワーク用のコードをコードベース全体に分散させたりすると、不可能ではないにしても、テストが極めて困難になる。 
- **データの関連性と新鮮さをできる限り維持する**  
こうすることで、デバイスがオフラインのときでも、ユーザーがアプリの機能を利用できるようになる。すべてのユーザーが常時高速接続を利用できるわけではなく、たとえ利用できるとしても、混雑した場所では受信不良が起きる可能性があることに留意する。    

## アーキテクチャのメリット
優れたアーキテクチャをアプリに実装することは、プロジェクトチームとエンジニアリングチームに次のような多くのメリットをもたらす。  
- アプリ全体の保守性、品質、堅牢性の向上
- アプリのスケーリングが可能になる。より多くの人々とチームが、コードの競合を最小限に抑えながら、同じコードベースで開発に寄与できる    
- オンボーディングに役立つ。アーキテクチャによってプロジェクトに一貫性がもたらされるため、新しいメンバーが速やかにチームに適応し、短時間でより効率的に作業できるようになる。 　  
- テストが簡単になる。優れたアーキテクチャでは、一般的にテストしやすいシンプルな型が推奨される  
- 適切に定義されたプロセスを使用して、体系的にバグを調査できる  

アーキテクチャへの投資は、ユーザーにも直接的な影響を及ぼす。  
エンジニアリングチームの生産性が高まることで、アプリの安定性と機能性が向上する。ただし、アーキテクチャの実装には事前の準備時間の投資も必要である。  

## Androidアプリの一般的なアーキテクチャ
<img width="600" alt="スクリーンショット 2020-11-24 16 38 44" src="https://user-images.githubusercontent.com/16067422/100062987-cf5c9500-2e73-11eb-8550-d498de322e3e.png">
